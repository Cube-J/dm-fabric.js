<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>editable_polygon</title>
    <script src="../dist/fabric.js"></script>
    <style>
      .controls {
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <p>
        <button id="edit" onclick="Edit()">Toggle editing polygon</button>
        <button id="crop" onclick="crop()">crop</button>
        <button id="crop" onclick="switchSeletable()">switch selectable</button>
      </p>
    </div>
    <div class="container" style="position: relative;width: 100%;height: 70vh;">
      <canvas
        id="c"
        width="1400"
        height="788"
      ></canvas>
      <canvas id="canvas-mask" style="position: absolute;width: 100%;height: 100%;"></canvas>
    </div>
  </body>
  <script type="module">
    import * as A from "../dist/fabric.js";
    console.log(A);
    // Modify fabric.Canvas.getPointer to make the returned coordinates correct when canvas's object-fit is 'contain' or 'cover'.
    DM.fabric.Canvas.prototype.getPointer = function (e, ignoreVpt) {
      // return cached values if we are in the event processing chain
      if (this._absolutePointer && !ignoreVpt) {
        return this._absolutePointer;
      }
      if (this._pointer && ignoreVpt) {
        return this._pointer;
      }

      var pointer = DM.fabric.util.getPointer(e),
          upperCanvasEl = this.upperCanvasEl,
          bounds = upperCanvasEl.getBoundingClientRect(),
          boundsWidth = bounds.width || 0,
          boundsHeight = bounds.height || 0,
          cssScale;

      if (!boundsWidth || !boundsHeight ) {
        if ('top' in bounds && 'bottom' in bounds) {
          boundsHeight = Math.abs( bounds.top - bounds.bottom );
        }
        if ('right' in bounds && 'left' in bounds) {
          boundsWidth = Math.abs( bounds.right - bounds.left );
        }
      }

      this.calcOffset();
      pointer.x = pointer.x - this._offset.left;
      pointer.y = pointer.y - this._offset.top;
      if (!ignoreVpt) {
        pointer = this.restorePointerVpt(pointer);
      }

      var retinaScaling = this.getRetinaScaling();
      if (retinaScaling !== 1) {
        pointer.x /= retinaScaling;
        pointer.y /= retinaScaling;
      }

      if (boundsWidth === 0 || boundsHeight === 0) {
        // If bounds are not available (i.e. not visible), do not apply scale.
        cssScale = { width: 1, height: 1 };
      } else {
        // Mainly modify this part
        var cvsObjectFit = window.getComputedStyle(upperCanvasEl).objectFit;
        var cvsW = upperCanvasEl.width,
        cvsH = upperCanvasEl.height,
        cvsCssW = boundsWidth,
        cvsCssH = boundsHeight;
        cssScale = {
          width: cvsW / cvsCssW,
          height: cvsH / cvsCssH
        };
        var cvsWHRatio = cvsW/cvsH,
        cvsCssWHRatio = cvsCssW/cvsCssH;
        if(cvsObjectFit === "contain") {
          if(cvsWHRatio > cvsCssWHRatio) {
            // In the case, canvas content is not filled on the top and bottom.
            var cvsContentCssW = cvsCssW;
            var cvsContentCssH = cvsCssW/cvsWHRatio;
            return {
              x: pointer.x * cssScale.width,
              y: (pointer.y - (cvsCssH-cvsContentCssH)/2)*cssScale.width
            };
          } else {
            // In the case, canvas content is not filled on the left and right.
            var cvsContentCssW = cvsCssH*cvsWHRatio;
            var cvsContentCssH = cvsCssH;
            return {
              x: (pointer.x - (cvsCssW-cvsContentCssW)/2)*cssScale.height,
              y: pointer.y * cssScale.height
            };
          }
        } else if(cvsObjectFit === "cover") {
          if(cvsWHRatio > cvsCssWHRatio) {
            // In this case, part of width is invisible.
            return {
              x: (cvsW-cssScale.height*cvsCssW)/2+pointer.x*cssScale.height,
              y: pointer.y * cssScale.height
            };
          } else {
            // In this case, part of height is invisible.
            return {
              x: pointer.x * cssScale.width,
              y: (cvsH-cssScale.width*cvsCssH)/2+pointer.y*cssScale.width,
            };
          }
        } else {
          return {
            x: pointer.x * cssScale.width,
            y: pointer.y * cssScale.height
          };
        }
      }

      return {
        x: pointer.x * cssScale.width,
        y: pointer.y * cssScale.height
      };
    };






    function redirectEvent(eventType, fromElement, toElement) {
      fromElement.addEventListener(eventType, function (event) {
        toElement.dispatchEvent(new event.constructor(event.type, event));
        event.preventDefault();
        event.stopPropagation();
      });
    }

    const maskCanvas = document.querySelector("#canvas-mask");
    // maskCanvas.addEventListener("click", event=>{
    //   // document.querySelector(".upper-canvas").dispatchEvent(new MouseEvent(event.type, event));
    //   document.querySelector(".canvas-container").dispatchEvent(new MouseEvent(event.type, event));
    //   event.preventDefault();
    //   event.stopPropagation();
    // });

    var image = new Image(1400, 788);
    image.src = "image.jpg";
    // document.querySelector("body").append(img);
    let baseCanvas = document.querySelector("#c");
    // baseCanvas.width = 1400;
    // baseCanvas.height = 788;
    // let ctx = baseCanvas.getContext('2d');
    // image.addEventListener('load', e => {
    //   ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, baseCanvas.width, baseCanvas.height);
    // });

    var canvas = (this.__canvas = new DM.fabric.Canvas("c", {enableRetinaScaling: false}));
    // canvas.enableRetinaScaling = false;
    canvas.setDimensions({width: "100%", height: "100%"}, {cssOnly: true});
    // document.querySelector(".canvas-container").style.width = "100%";
    // document.querySelector(".canvas-container").style.height = "50vh";
    document.querySelector(".canvas-container").style.position = "absolute";
    document.querySelector(".canvas-container").style.border = "1px solid black";
    // document.querySelector(".canvas-container").style.objectFit = "contain";
    // document.querySelector("#c").style.width = "100%";
    // document.querySelector("#c").style.height = "100%";
    // document.querySelector("#c").style.objectFit = "contain";
    document.querySelector("#c").style.objectFit = "cover";
    // document.querySelector(".upper-canvas").style.width = "100%";
    // document.querySelector(".upper-canvas").style.height = "100%";
    // document.querySelector(".upper-canvas").style.objectFit = "contain";
    document.querySelector(".upper-canvas").style.objectFit = "cover";

    redirectEvent("mousedown", maskCanvas, document.querySelector(".upper-canvas"));

    var imgInstance = new DM.fabric.Image(image, {
      left: 0,
      top: 0,
      angle: 0,
      opacity: 0.85
    });
    // canvas.width = imgInstance.width;
    // canvas.height = imgInstance.height;
    // canvas.backgroundImage = imgInstance;
    canvas.setBackgroundImage('image.jpg', canvas.renderAll.bind(canvas));

    function crop(){
      const boundingRect = polygon.getBoundingRect();
      console.log(boundingRect);
      const cvs = document.createElement("canvas");
      cvs.width = boundingRect.width;
      cvs.height = boundingRect.height;
      const ctx = cvs.getContext("2d");


      var points = [];
      for(let i in polygon.oCoords) {
        points.push({
          x: polygon.oCoords[i].x-boundingRect.left,
          y: polygon.oCoords[i].y-boundingRect.top
        })
      }

      console.log(points);

      ctx.beginPath();
      ctx.moveTo(points[0].x,points[0].y);
      for(var i=1;i<points.length;i++){
          var p=points[i];
          ctx.lineTo(points[i].x,points[i].y);
      }
      ctx.closePath();
      ctx.clip();

      ctx.drawImage(image, boundingRect.left, boundingRect.top, boundingRect.width, boundingRect.height, 0, 0, boundingRect.width, boundingRect.height);
      // ctx.drawImage(image, polygon.left, polygon.top, polygon.width, polygon.height);
      document.querySelector("body").append(cvs);
      cvs.style.objectFit = "contain";
    }

    function switchSeletable() {
      if(polygon.selectable) {
        polygon.selectable = false;
        polygon.evented = false;
        polygon.hasControls = false;
        polygon.hasBorders = false;
        canvas.renderAll();
      } else {
        polygon.selectable = true;
        polygon.evented = true;
        polygon.hasControls = true;
        // polygon.hasBorders = !polygon.edit;
        polygon.hasBorders = true;
      }
    }

    const rect = new DM.fabric.Rect({
      left: 100,
      top: 500,
      width: 1000,
      height: 100,
      fill: "transparent",
      stroke: "red"
    });
    canvas.add(rect);
    rect.onSelect = ()=>console.log("rect is selected!");
    rect.onDeselect = ()=>console.log("rect is deselect!");

    // create a polygon object
    var points = [
      {
        x: 200,
        y: 200,
      },
      {
        x: 300,
        y: 200,
      },
      {
        x: 300,
        y: 300,
      },
      {
        x: 200,
        y: 300,
      },
    ];
    var polygon = new DM.fabric.Polygon(points, {
      left: 200,
      top: 0,
      fill: "transparent",
      strokeWidth: 4,
      stroke: "orange",
      scaleX: 1,
      scaleY: 1,
      objectCaching: false,
      transparentCorners: false,
      cornerColor: "blue",
      // perPixelTargetFind: true
    });
    //canvas.viewportTransform = [0.7, 0, 0, 0.7, -50, 50];
    canvas.add(polygon);

    // define a function that can locate the controls.
    // this function will be used both for drawing and for interaction.
    function polygonPositionHandler(dim, finalMatrix, fabricObject) {
      var x =
          fabricObject.points[this.pointIndex].x - fabricObject.pathOffset.x,
        y =
          fabricObject.points[this.pointIndex].y - fabricObject.pathOffset.y;
      return DM.fabric.util.transformPoint(
        { x: x, y: y },
        DM.fabric.util.multiplyTransformMatrices(
          fabricObject.canvas.viewportTransform,
          fabricObject.calcTransformMatrix()
        )
      );
    }

    function getObjectSizeWithStroke(object) {
      var stroke = new DM.fabric.Point(
        object.strokeUniform ? 1 / object.scaleX : 1,
        object.strokeUniform ? 1 / object.scaleY : 1
      ).multiply(object.strokeWidth);
      return new DM.fabric.Point(
        object.width + stroke.x,
        object.height + stroke.y
      );
    }

    // define a function that will define what the control does
    // this function will be called on every mouse move after a control has been
    // clicked and is being dragged.
    // The function receive as argument the mouse event, the current trasnform object
    // and the current position in canvas coordinate
    // transform.target is a reference to the current object being transformed,
    function actionHandler(eventData, transform, x, y) {
      var polygon = transform.target,
        currentControl = polygon.controls[polygon.__corner],
        mouseLocalPosition = polygon.toLocalPoint(
          new DM.fabric.Point(x, y),
          "center",
          "center"
        ),
        polygonBaseSize = getObjectSizeWithStroke(polygon),
        size = polygon._getTransformedDimensions(0, 0),
        finalPointPosition = {
          x:
            (mouseLocalPosition.x * polygonBaseSize.x) / size.x +
            polygon.pathOffset.x,
          y:
            (mouseLocalPosition.y * polygonBaseSize.y) / size.y +
            polygon.pathOffset.y,
        };
      polygon.points[currentControl.pointIndex] = finalPointPosition;
      return true;
    }

    // define a function that can keep the polygon in the same position when we change its
    // width/height/top/left.
    function anchorWrapper(anchorIndex, fn) {
      return function (eventData, transform, x, y) {
        var fabricObject = transform.target,
          absolutePoint = DM.fabric.util.transformPoint(
            {
              x:
                fabricObject.points[anchorIndex].x -
                fabricObject.pathOffset.x,
              y:
                fabricObject.points[anchorIndex].y -
                fabricObject.pathOffset.y,
            },
            fabricObject.calcTransformMatrix()
          ),
          actionPerformed = fn(eventData, transform, x, y),
          newDim = fabricObject._setPositionDimensions({}),
          polygonBaseSize = getObjectSizeWithStroke(fabricObject),
          newX =
            (fabricObject.points[anchorIndex].x - fabricObject.pathOffset.x) /
            polygonBaseSize.x,
          newY =
            (fabricObject.points[anchorIndex].y - fabricObject.pathOffset.y) /
            polygonBaseSize.y;
        fabricObject.setPositionByOrigin(
          absolutePoint,
          newX + 0.5,
          newY + 0.5
        );
        return actionPerformed;
      };
    }

    function Edit() {
      // clone what are you copying since you
      // may want copy and paste on different moment.
      // and you do not want the changes happened
      // later to reflect on the copy.
      var poly = canvas.getObjects()[0];
      canvas.setActiveObject(poly);
      poly.edit = !poly.edit;
      if (poly.edit) {
        var lastControl = poly.points.length - 1;
        poly.cornerStyle = "circle";
        poly.cornerColor = "rgba(0,0,255,0.5)";
        poly.controls = poly.points.reduce(function (acc, point, index) {
          acc["p" + index] = new DM.fabric.Control({
            positionHandler: polygonPositionHandler,
            actionHandler: anchorWrapper(
              index > 0 ? index - 1 : lastControl,
              actionHandler
            ),
            actionName: "modifyPolygon",
            pointIndex: index,
          });
          return acc;
        }, {});
      } else {
        poly.cornerColor = "blue";
        poly.cornerStyle = "rect";
        poly.controls = DM.fabric.Object.prototype.controls;
      }
      poly.hasBorders = !poly.edit;
      canvas.requestRenderAll();
    }
  </script>
</html>
